В данной папке размещаем скриптовые файлы *.js

Динамическая составляющая макета:

1. Общие вспомогательные функции и переменные
В этом блоке определены глобальные переменные и функции, которые используются в нескольких частях скрипта.

lockScroll(): Блокирует прокрутку страницы, добавляя overflow: hidden к <body>. Используется при открытии модальных окон, лайтбокса или мобильного меню.
unlockScroll(): Снимает блокировку прокрутки, восстанавливая стандартное поведение overflow.
closeModal, closeLightbox, closeMobileMenu: Эти функции изначально объявлены как пустые. Они переопределяются в соответствующих блоках. Такое объявление необходимо, чтобы сделать их доступными для глобального обработчика нажатия клавиши Escape.
2. Прелоадер (Preloader)
Цель: Показать экран загрузки, пока все ресурсы страницы (изображения, стили) не будут полностью загружены.
Логика:
Находит элемент #preloader.
Вешает слушатель на событие window.load, которое срабатывает после полной загрузки страницы.
После срабатывания события, с задержкой в 500 мс, прелоадеру добавляется класс preloader--hidden. Этот класс отвечает за анимацию плавного исчезновения.
3. Кастомный курсор (Custom Cursor)
Цель: Заменить стандартный курсор операционной системы на стилизованный, состоящий из двух элементов.
Элементы:
.cursor: Маленькая точка, которая точно следует за указателем мыши.
.cursor-follower: Больший круг, который следует за курсором с небольшой задержкой, создавая "шлейф".
Логика:
Слушатель window.mousemove постоянно обновляет transform: translate() для обоих элементов курсора, перемещая их по координатам e.clientX и e.clientY.
При наведении на интерактивные элементы (a, button, .gallery__item, .slider-btn), элементу .cursor-follower добавляется класс is-active, который в CSS увеличивает его размер, создавая эффект подсветки.
4. Шапка и навигация (Header & Navigation)
Этот блок отвечает за поведение шапки сайта и мобильной навигации.

"Прилипающая" шапка:
Слушатель window.scroll отслеживает позицию прокрутки.
Если window.scrollY > 50, шапке .header добавляется класс header--scrolled. Этот класс используется в CSS для изменения внешнего вида шапки (например, добавления фона или тени).
Мобильное меню (Бургер):
При клике на иконку бургера (#burger) происходит переключение состояния меню.
Если меню закрыто, бургеру добавляется класс is-active (для анимации крестика), навигации #nav — класс nav--open (для отображения), и вызывается lockScroll().
Если меню открыто, происходит обратное действие с помощью функции closeMobileMenu().
Плавная прокрутка:
Всем ссылкам в навигации (.nav__link) добавлен слушатель клика.
При клике отменяется стандартное поведение (e.preventDefault()), и страница плавно прокручивается к элементу, id которого указан в href ссылки, с помощью scrollIntoView({ behavior: 'smooth' }).
Если при этом было открыто мобильное меню, оно закрывается.
5. Анимации при прокрутке (Scroll Animations)
Цель: Плавно показывать элементы, когда пользователь до них доскролливает.
Технология: IntersectionObserver — современный и производительный API для отслеживания видимости элементов.
Логика:
Общая анимация ([data-animate]): Элементы с этим атрибутом отслеживаются. Когда элемент появляется в области видимости (на 10%), ему добавляется класс is-visible, который запускает CSS-анимацию (например, opacity или transform).
Анимация текста ([data-animate-text]):
Текст внутри элемента с этим атрибутом автоматически разбивается на отдельные символы, каждый из которых оборачивается в <span> с классом char.
Когда такой элемент становится видимым, каждому <span> добавляется CSS-свойство transition-delay с нарастающим значением (index * 50ms). Это создает эффект "печатающегося" или появляющегося по буквам текста.
Оптимизация: После того как анимация элемента сработала один раз, IntersectionObserver прекращает за ним следить (observer.unobserve), чтобы не тратить ресурсы браузера.
6. Карусель отзывов (Swiper.js)
Цель: Создать интерактивную, автоматически прокручивающуюся карусель для блока с отзывами.
Технология: Используется сторонняя библиотека Swiper.js.
Конфигурация:
loop: true: Бесконечная прокрутка слайдов.
grabCursor: true: Курсор меняется на "руку" при наведении на слайдер.
effect: 'fade': Слайды сменяются через эффект затухания, а не листания.
autoplay: Автоматическая прокрутка с задержкой 6 секунд. Не останавливается при взаимодействии пользователя.
navigation: Подключает стрелки "вперед/назад" (.swiper-button-next, .swiper-button-prev).
pagination: Подключает кликабельные точки для навигации (.reviews-pagination).
7. Лайтбокс для галереи (Gallery Lightbox)
Цель: Реализовать модальное окно для просмотра изображений из галереи в полном размере.
Логика (алгоритм):
Инициализация:
Находятся все DOM-элементы: сам лайтбокс (#lightbox), его <img>, кнопки навигации и закрытия.
Создается массив imageSources с URL всех полноразмерных изображений из галереи.
Создается переменная currentImageIndex для отслеживания текущего открытого изображения.
Открытие:
На каждое изображение в галерее (.gallery__item) вешается слушатель клика.
При клике вызывается функция openLightbox(index), которая:
Обновляет currentImageIndex.
Устанавливает нужный src для <img> внутри лайтбокса.
Добавляет класс is-open для отображения лайтбокса.
Блокирует прокрутку страницы (lockScroll()).
Навигация:
Кнопки "вперед" и "назад" изменяют currentImageIndex (с зацикливанием по кругу) и обновляют src изображения.
Закрытие:
Лайтбокс закрывается по клику на крестик, на темный фон за пределами изображения или по нажатию клавиши Escape.
Вызывается функция closeLightbox(), которая убирает класс is-open и разблокирует прокрутку (unlockScroll()).
8. Модальное окно и форма записи
Этот блок реализует функциональность модального окна с формой для записи на услугу.

Управление окном:
Кнопки с id="open-modal-btn" и id="open-modal-btn-hero" открывают модальное окно (#modal).
Закрытие происходит по клику на крестик (#close-modal-btn), по клику на фон или по нажатию Escape.
Интеграция с LocalStorage:
loadUserData(): При открытии модального окна эта функция проверяет, есть ли в localStorage сохраненные данные клиента (auraClientData). Если есть, она подставляет имя и телефон в поля формы.
saveUserData(): После успешной валидации и отправки формы эта функция сохраняет введенные имя и телефон в localStorage для будущего использования.
Маска ввода для телефона:
Поле для ввода телефона автоматически форматирует вводимые цифры в формат +7 (XXX) XXX-XX-XX, игнорируя все нечисловые символы.
Валидация формы:
Перед отправкой функция validateForm() проверяет поля:
Имя: не менее 2 символов.
Телефон: ровно 11 цифр.
Дата: поле не должно быть пустым.
При ошибке под полем выводится текст ошибки, а само поле подсвечивается.
Отправка формы:
Отправка имитируется с помощью setTimeout.
Пользователь видит сообщения "Отправляем вашу заявку...", а затем "Спасибо, ...! Ваша заявка принята.".
После успешной отправки модальное окно автоматически закрывается через 3 секунды.
9. Кнопка "Наверх" (Back to Top)
Цель: Предоставить пользователю удобный способ быстро вернуться в начало страницы.
Логика:
Кнопка #back-to-top скрыта по умолчанию.
Слушатель window.scroll отслеживает прокрутку. Если она превышает 300px, кнопке добавляется класс is-visible, делая ее видимой.
При клике на кнопку происходит плавная прокрутка в самый верх страницы с помощью window.scrollTo({ top: 0, behavior: 'smooth' }).
10. Демонстрационные задания
Этот блок содержит код, написанный для демонстрации конкретных навыков.

Задание 9: Слушатель событий: На шапку .header добавлен простой слушатель mouseover, который выводит в консоль сообщение при наведении курсора.
Задание 10: Генерация верстки (for...in):
Создан объект principlesData, содержащий информацию о принципах работы салона.
С помощью цикла for...in скрипт итерируется по этому объекту и динамически создает HTML-карточки для каждого принципа, вставляя их в контейнер #principles-container.
Созданные карточки также получают атрибут data-animate и начинают отслеживаться IntersectionObserver'ом для анимации при появлении.
Задание 11: Работа с JSON (fetch):
Реализована асинхронная функция loadServices(), которая загружает данные из локального файла data.json с помощью fetch.
После успешного получения и парсинга JSON, скрипт динамически создает HTML-верстку для карточек услуг и вставляет их в контейнер #services-container.
Включена обработка ошибок (try...catch): если файл не найден или произошла другая ошибка, в контейнер выводится сообщение об ошибке.
11. Глобальный обработчик нажатия клавиш
Цель: Обеспечить интуитивное закрытие всех оверлеев (модальных окон, лайтбоксов) по нажатию одной клавиши.
Логика:
На window установлен слушатель события keydown.
Если нажата клавиша Escape, скрипт проверяет, открыто ли в данный момент модальное окно, лайтбокс или мобильное меню.
Если какой-либо из этих элементов активен, вызывается соответствующая функция для его закрытия (closeModal(), closeLightbox() или closeMobileMenu()).